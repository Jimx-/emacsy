\section{Core}

\epigraph{...}{...}

Now we're going to put in place some core functionality that makes
Emacsy an Emacs-like library.  

We need a global keymap.  

<<core:state>>=
(define-public global-map (make-keymap))
@ 

<<core:procedure>>=
(define-public (current-minor-mode-maps)
  (list))

(define-public (current-active-maps)
  (list (current-local-map) global-map))

(set! default-klecl-maps current-active-maps)
@ 

And here are the most essential key bindings.

<<core:keybinding>>=
(define-key global-map (kbd "M-:")     'eval-expression)
(define-key global-map (kbd "M-x")     'execute-extended-command)
(define-key global-map (kbd "C-g")     'keyboard-quit)
(define-key global-map (kbd "C-x C-c") 'quit-application)
@ 

There is one command that I consider fundamental for an Emacs-like
program.  Whenever I'm presented with a program that claims to be
Emacs-like, I try this out \verb|M-: (+ 1 2)|. If it doesn't work then
it may have Emacs-like key bindings, but it's not Emacs-like.  That
command is [[eval-expression]].  Let's write it.

<<core:command>>=
(define-interactive 
  (eval-expression
   #:optional (expression (read-from-string (read-from-minibuffer "Eval: "))))
  (let ((value (eval expression (interaction-environment))))
    (message "~a" value)
    value))
@ 



<<core:test>>=
(check (eval-expression '(+ 1 2)) => 3)
@ 
[[read-from-string]] parses the string into an expression.

<<util:procedure>>=
(define-public (read-from-string string)
  (call-with-input-string string (lambda (port) (read port))))
@ 

The second fundamental command is [[execute-extended-command]] invoked
with \verb|M-x|.

<<core:command>>=
(define-interactive (execute-extended-command #:optional (n 1))
  (display "HERE!\n")
  (let ((str (completing-read "M-x " (completer global-cmdset))))
    (call-interactively (string->symbol str))))
@ 

<<core:command>>=
(define-interactive (quit-application)
  (set! emacsy-quit-application? #t))
@ 

<<core:state>>=
(define-public emacsy-quit-application? #f)
@ 

\subsubsection{Keyboard Macro Keybindings}

<<core:keybinding>>=
(define-key global-map (kbd "C-x (") 'kmacro-start-macro)
(define-key global-map (kbd "C-x )") 'kmacro-end-macro)
(define-key global-map (kbd "C-x e") 'kmacro-end-and-call-macro)
@ 

\subsubsection{Buffer Manipulation Keybindings}

<<core:keybinding>>=
(define-key global-map (kbd "C-o")   'other-buffer)
(define-key global-map (kbd "C-x k") 'kill-buffer)
@ 

\subsection{Messages Buffer}

<<core:state>>=
(define messages 
  (make <text-buffer> #:keymap (make-keymap) #:name "*Messages*"))
@ 

<<core:process>>=
(add-buffer! messages)
@ 

<<core:procedure>>=
(define echo-area "")

(define-public (emacsy-echo-area)
  echo-area)

(define-public (current-message)
  echo-area)

(define (emacsy-message . args)
  (let ((string (apply format #f args)))
   (with-buffer messages
                (insert string)
                (insert "\n"))
   (set! echo-area string)
   (format #t "MESSAGE: ~a\n" string)
   string))

;; There's probably a better way to do this.
(set! message emacsy-message)
@ 

We want to be able to load a scheme file.\todo{We should have a
  read-filename procedure.}

<<core:command>>=
(define-interactive 
  (load-file #:optional (filename (read-from-minibuffer "Filename: ")))
  (catch #t
    #.\ (begin (load filename)
               (message "Loaded ~a." filename)
               #t)
    (lambda (key . args)
      (let ((error-msg 
             (call-with-output-string 
              #.\ (apply display-error #f % args))))
        (message "Failed to load ~a: ~a" filename error-msg)
        #f))))
@ 

These are most of the C API calls.

<<core:procedure>>=
(define-public (emacsy-message-or-echo-area)
  (if emacsy-display-minibuffer?
      (buffer-string minibuffer)
      echo-area))

(define-public (emacsy-mode-line)
  (format #f "-:**- ~a" (buffer-name)))

(define-public (emacsy-minibuffer-point)
  (if emacsy-display-minibuffer?
      (point minibuffer)
      -1))

(define-public emacsy-terminate-hook (make-hook))

(define-public (emacsy-terminate)
  (run-hook emacsy-terminate-hook))

(define-public (emacsy-tick)
  (block-tick))
@ 

We want to be able to define variables that are not redefined if a
source file or module is reloaded.

<<core:macro>>=
(define-syntax-public define-variable
  (syntax-rules ()
    ;; Should be able to include a description.
    ((define-variable name variable)
     (if (not (module-variable (current-module) 'name))
         (module-define! (current-module) 'name variable)))))
@ 

\subsection{Mouse Movement}

Sometimes we may want to track the motion events generated by a mouse.
We don't do this all the time because it seems unnecessarily taxing.  

<<core:state>>=
(define-public emacsy-send-mouse-movement-events? #f)
@ 

<<core:macro>>=
(define-syntax-public track-mouse
  (syntax-rules ()
    ((track-mouse e ...)
     (in-out-guard  ;; This is different from dynamic-wind.
       (lambda () (set! emacsy-send-mouse-movement-events? #t))
       (lambda () e ...)
       (lambda () (set! emacsy-send-mouse-movement-events? #f))))))
@ 

<<core:procedure>>=
(define*-public (read-from-mouse #:optional (prompt #f))
  (define (my-read-event) 
    (if (and (pair? this-command-event)
             (mouse-event? (car this-command-event)))
        (let ((event (car this-command-event)))
          (set! this-command-event (cdr this-command-event))
          event)
          ;; XXX Should this be read-key or read-event?
        (read-event prompt)))
  (let loop ((event (my-read-event)))
    (if (mouse-event? event)
        ;; Got an event.
        (position event)
        (let ((canceled? #f))
          ;; Put this event back in the queue.  
          (emacsy-event event)
          (catch
            'quit-command
            (lambda () (primitive-command-tick))
            (lambda (key . args)
              (display "READ-FROM-MOUSE CANCELED\n")
              (set! canceled? #t)))
          (if canceled?
              (throw 'quit-command 'quit-read-from-mouse)
              (loop (my-read-event)))))))
@

<<core:test>>=
(emacsy-discard-input!)
(emacsy-key-event #\a)
(define mouse-event #f)
(with-blockable (set! mouse-event (read-from-mouse)))
(block-tick)
(check mouse-event => #f)
(emacsy-mouse-event #(0 0) 1 'down)
(block-tick)
(check-true mouse-event)
@ 

\subsection{Command Loop}

If we ever run out of command loops due to errors, we start a new one.

<<core:procedure>>=
(define (restart-command-loop)
  ;; Start another command-loop
  (display "NO COMMAND LOOPS; STARTING ANOTHER.")
  (call-blockable (lambda () (command-loop))))
@ 

<<core:process>>=
(add-hook! no-blocking-continuations-hook restart-command-loop)
@ 

\subsection*{File Layout} 

<<emacsy/core.scm>>=
(define-module (emacsy core)
  #:use-module (ice-9 optargs)
  #:use-module (oop goops)
  #:use-module (rnrs io ports)
  #:use-module (debugging assert)
  #:use-module (srfi srfi-1)
  #:use-module (convenience-lambda)  
  #:use-module (emacsy util)
  #:use-module (emacsy keymap)
  #:use-module (emacsy event)
  #:use-module (emacsy buffer)
  #:use-module (emacsy command)
  #:use-module (emacsy block)
  #:use-module (emacsy klecl)
  #:use-module (emacsy kbd-macro)
  #:use-module (emacsy minibuffer))
<<core:macro>>
<<core:class>>
<<core:state>>
<<core:procedure>>
<<core:command>>
<<core:keybinding>>
<<core:process>>
@ 

Layout for tests.
<<core-tests.scm>>=
(use-modules (emacsy core)
             (emacsy event)
             (emacsy klecl)
             (oop goops))

(eval-when (compile load eval)
           ;; Some trickery so we can test private procedures.
           (module-use! (current-module) (resolve-module '(emacsy core))))

<<+ Test Preamble>>
<<core:test>>
<<+ Test Postscript>>
@ 
 
